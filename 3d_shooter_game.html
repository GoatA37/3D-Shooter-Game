
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Shooter Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<script type="module">
// Import necessary libraries
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.136/build/three.module.js';
import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.136/examples/jsm/controls/PointerLockControls.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

// Setup scene, camera, and renderer
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// Player Stats
let playerHealth = 100;
let playerShield = 100;
let ammo = 10;
const maxAmmo = 10;

// UI
const ui = document.createElement('div');
ui.style.position = 'absolute';
ui.style.top = '10px';
ui.style.left = '10px';
ui.style.color = 'white';
ui.style.fontSize = '20px';
document.body.appendChild(ui);

// Update UI Function
function updateUI() {
    ui.innerHTML = `Health: ${playerHealth} Shield: ${playerShield} Ammo: ${ammo}`;
    if (playerHealth <= 0) {
        ui.innerHTML = "Game Over! Refresh to restart.";
        cancelAnimationFrame(animationID);
    }
}

// Controls
const controls = new PointerLockControls(camera, document.body);
document.addEventListener('click', () => {
    if (document.pointerLockElement !== document.body) {
        document.body.requestPointerLock();
    }
    controls.lock();
});
scene.add(camera);

// Physics World
const world = new CANNON.World();
world.gravity.set(0, -9.8, 0);

// Player Physics
const playerBody = new CANNON.Body({ mass: 1, shape: new CANNON.Sphere(1.3) });
playerBody.position.set(0, 5, 0);
world.addBody(playerBody);

// Map
const mapSize = 200;
const terrain = new THREE.Mesh(
    new THREE.PlaneGeometry(mapSize, mapSize),
    new THREE.MeshStandardMaterial({ color: 0x228B22, side: THREE.DoubleSide })
);
terrain.rotation.x = -Math.PI / 2;
scene.add(terrain);

const terrainBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
terrainBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
world.addBody(terrainBody);

// Lighting (for performance)
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(10, 20, 10);
scene.add(light);

// Player Movement
const playerSpeed = 3.5;
const jumpForce = 6;
const movement = { forward: false, backward: false, left: false, right: false, jump: false };

document.addEventListener('keydown', (event) => {
    if (event.key === 'w') movement.forward = true;
    if (event.key === 's') movement.backward = true;
    if (event.key === 'a') movement.left = true;
    if (event.key === 'd') movement.right = true;
    if (event.key === ' ') movement.jump = true;
    if (event.key === 'r') reloadAmmo();
});

document.addEventListener('keyup', (event) => {
    if (event.key === 'w') movement.forward = false;
    if (event.key === 's') movement.backward = false;
    if (event.key === 'a') movement.left = false;
    if (event.key === 'd') movement.right = false;
    if (event.key === ' ') movement.jump = false;
});

// Enemy AI
class Enemy {
    constructor(x, y, z) {
        this.mesh = new THREE.Mesh(
            new THREE.SphereGeometry(1, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0xff0000 })
        );
        this.mesh.position.set(x, y, z);
        scene.add(this.mesh);
        this.health = 20;
        this.attackCooldown = 0;
    }

    moveTowardsPlayer() {
        const direction = new THREE.Vector3().subVectors(camera.position, this.mesh.position).normalize();
        this.mesh.position.addScaledVector(direction, 0.015); // Slower movement for performance
    }

    attackPlayer() {
        if (this.mesh.position.distanceTo(camera.position) < 2 && this.attackCooldown <= 0) {
            if (playerShield > 0) {
                playerShield -= 10;
            } else {
                playerHealth -= 10;
            }
            this.attackCooldown = 100;
            updateUI();
        }
        if (this.attackCooldown > 0) this.attackCooldown--;
    }

    takeDamage() {
        this.health -= 10;
        if (this.health <= 0) {
            scene.remove(this.mesh);
            enemies.splice(enemies.indexOf(this), 1);
        }
    }
}

const enemies = [];

// Spawning Enemies
function spawnEnemy() {
    if (playerHealth > 0) {
        const x = (Math.random() - 0.5) * mapSize;
        const z = (Math.random() - 0.5) * mapSize;
        enemies.push(new Enemy(x, 1, z));
        setTimeout(spawnEnemy, 8000); // Reduced spawn rate for Chromebook performance
    }
}
spawnEnemy();

// Shooting Mechanic
const bullets = [];
document.addEventListener('mousedown', () => {
    if (ammo > 0) {
        ammo--;
        updateUI();

        const bullet = new THREE.Mesh(
            new THREE.SphereGeometry(0.2, 8, 8),
            new THREE.MeshStandardMaterial({ color: 0xffff00 })
        );
        bullet.position.copy(camera.position);
        scene.add(bullet);
        bullets.push({ mesh: bullet, direction: camera.getWorldDirection(new THREE.Vector3()) });
    }
});

// Reload Mechanic
function reloadAmmo() {
    if (ammo < maxAmmo) {
        ammo = maxAmmo;
        updateUI();
    }
}

// Game Loop
let animationID;
const animate = () => {
    animationID = requestAnimationFrame(animate);
    world.step(1 / 60);

    let velocity = new CANNON.Vec3();
    if (movement.forward) velocity.z -= playerSpeed;
    if (movement.backward) velocity.z += playerSpeed;
    if (movement.left) velocity.x -= playerSpeed;
    if (movement.right) velocity.x += playerSpeed;
    if (movement.jump && Math.abs(playerBody.velocity.y) < 0.01) playerBody.velocity.y = jumpForce;

    playerBody.velocity.set(velocity.x, playerBody.velocity.y, velocity.z);
    camera.position.copy(playerBody.position);

    // Update enemies
    enemies.forEach(enemy => {
        enemy.moveTowardsPlayer();
        enemy.attackPlayer();
    });

    // Bullet movement & collision
    bullets.forEach((bullet, index) => {
        bullet.mesh.position.addScaledVector(bullet.direction, 0.8);

        // Check collision with enemies
        enemies.forEach(enemy => {
            if (bullet.mesh.position.distanceTo(enemy.mesh.position) < 1) {
                enemy.takeDamage();
                scene.remove(bullet.mesh);
                bullets.splice(index, 1);
            }
        });

        if (bullet.mesh.position.distanceTo(camera.position) > 50) {
            scene.remove(bullet.mesh);
            bullets.splice(index, 1);
        }
    });

    renderer.render(scene, camera);
};

animate();
</script>

</body>
</html>
